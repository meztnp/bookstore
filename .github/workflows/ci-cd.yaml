name: CI/CD Pipeline

on:
  push:
    branches:
      - main  # Trigger this pipeline when pushing to the main branch
  pull_request:
    branches:
      - main  # Trigger on pull requests targeting the main branch

permissions:
  id-token: write

jobs:
  checkout-and-setup:
    runs-on: ubuntu-latest
    outputs:
      kubeconfig: ${{ steps.set-kubeconfig.outputs.kubeconfig }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2
 
      - name: Save Repository as Artifact
        uses: actions/upload-artifact@v3
        with:
          name: repo-files
          path: .
 
      - name: Azure Login (Only Once)
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
 
      - name: Set Kubernetes Context
        id: set-kubeconfig
        run: |
          az aks get-credentials --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} --name ${{ secrets.AZURE_CLUSTER_NAME }}
          echo "kubeconfig=$(base64 ~/.kube/config -w 0)" >> "$GITHUB_OUTPUT"

  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Download Repository
        uses: actions/download-artifact@v3
        with:
          name: repo-files
          path: .

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version  # Verify installation

      - name: Build & Push Stack Images
        run: |
          docker-compose -f docker-compose.yml build
          docker-compose -f docker-compose.yml push

  apply-predeploy:
    runs-on: ubuntu-latest
    needs: checkout-and-setup
    steps:
      - name: Download Repository
        uses: actions/download-artifact@v3
        with:
          name: repo-files
          path: .

      - name: Restore Kubernetes Context
        run: |
          echo "${{ needs.checkout-and-setup.outputs.kubeconfig }}" | base64 --decode > ~/.kube/config
          export KUBECONFIG=~/.kube/config

      - name: Apply Configurations Before Deploying
        run: |
          kubectl apply -f kubernetes/frontend/frontend-configmap.yml

      - name: Deploy Database
        run: |
          kubectl apply -f kubernetes/db/postgres-deployment.yaml
          
      - name: Install Velero CRDs
        run: |
          kubectl apply -f velero-crds/

      - name: Apply Velero
        run: |
          kubectl apply -f kubernetes/velero/velero-secret.yml -n velero
          kubectl apply -f kubernetes/velero/velero-schedule.yml -n velero

  helm-upgrade:
    runs-on: ubuntu-latest
    needs: apply-predeploy
    steps:
      - name: Restore Kubernetes Context
        run: |
          echo "${{ needs.checkout-and-setup.outputs.kubeconfig }}" | base64 --decode > ~/.kube/config
          export KUBECONFIG=~/.kube/config
    
      - name: Helm Install 
        run: |
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo add vmware-tanzu https://vmware-tanzu.github.io/helm-charts
          helm repo update

      - name: Install or Upgrade Kubernetes Tools
        run: |
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx --namespace ingress-nginx --create-namespace --wait
          helm upgrade --install velero vmware-tanzu/velero \
          --namespace velero --create-namespace \
          --set configuration.backupStorageLocation[0].name=default \
          --set configuration.backupStorageLocation[0].bucket=velero-backups \
          --set configuration.backupStorageLocation[0].provider=azure \
          --set configuration.backupStorageLocation[0].config.resourceGroup=bookstore-rg \
          --set configuration.backupStorageLocation[0].credential.secretContents.cloud=velero-credentials \
          --set configuration.volumeSnapshotLocation[0].name=default \
          --set configuration.volumeSnapshotLocation[0].provider=azure \
          --set configuration.volumeSnapshotLocation[0].config.resourceGroup=bookstore-rg \
          --set configuration.volumeSnapshotLocation[0].credential.secretContents.cloud=velero-credentials --wait

  determine-target:
    runs-on: ubuntu-latest
    needs: helm-upgrade
    outputs:
      target_color: ${{ steps.set-color.outputs.target_color }}
      idle_color: ${{ steps.set-color.outputs.idle_color }}
    steps:
      - name: Restore Kubernetes Context
        run: |
          echo "${{ needs.checkout-and-setup.outputs.kubeconfig }}" | base64 --decode > ~/.kube/config
          export KUBECONFIG=~/.kube/config

      - name: Check current active version for services
        id: set-color
        run: |
          CURRENT_COLOR=$(kubectl get service catalog-service -o jsonpath='{.spec.selector.version}')
          if [ "$CURRENT_COLOR" == "blue" ]; then
            echo "Deploying Green next..."
            echo "target_color=green" >> $GITHUB_OUTPUT
            echo "idle_color=blue" >> $GITHUB_OUTPUT
          else
            echo "Deploying Blue next..."
            echo "target_color=blue" >> $GITHUB_OUTPUT
            echo "idle_color=green" >> $GITHUB_OUTPUT

  deploy-new:
    runs-on: ubuntu-latest
    needs: determine-target
    steps:
      - name: Download Repository
        uses: actions/download-artifact@v3
        with:
          name: repo-files
          path: .
          
      - name: Restore Kubernetes Context
        run: |
          echo "${{ needs.checkout-and-setup.outputs.kubeconfig }}" | base64 --decode > ~/.kube/config
          export KUBECONFIG=~/.kube/config

      - name: Deploy new (Blue/Green) version for all services
        run: |
          kubectl apply -f kubernetes/catalog/catalog-${{ needs.determine-target.outputs.target_color }}-deployment.yaml
          kubectl apply -f kubernetes/cart/cart-${{ needs.determine-target.outputs.target_color }}-deployment.yaml
          kubectl apply -f kubernetes/frontent/frontend-${{ needs.determine-target.outputs.target_color }}-deployment.yaml

      - name: Apply Kubernetes Services
        run: |
          kubectl apply -f kubernetes/catalog/catalog-service.yaml
          kubectl apply -f kubernetes/cart/cart-service.yaml
          kubectl apply -f kubernetes/frontent/frontend-service.yaml

      - name: Apply Kubernetes HPA
        run: |
          kubectl apply -f kubernetes/catalog/catalog-${{ needs.determine-target.outputs.target_color }}-hpa.yaml
          kubectl apply -f kubernetes/cart/cart-${{ needs.determine-target.outputs.target_color }}-hpa.yaml
          kubectl apply -f kubernetes/frontent/frontend-${{ needs.determine-target.outputs.target_color }}-hpa.yaml

      - name: Apply Kubernetes Ingress
        run: |
          kubectl apply -f kubernetes/catalog/catalog-ingress.yaml
          kubectl apply -f kubernetes/cart/cart-ingress.yaml
          kubectl apply -f kubernetes/frontent/frontend-ingress.yaml

  restart-pods:
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-new]
    steps:
      - name: Restore Kubernetes Context
        run: |
          echo "${{ needs.checkout-and-setup.outputs.kubeconfig }}" | base64 --decode > ~/.kube/config
          export KUBECONFIG=~/.kube/config

      - name: Restart Pods to Ensure Latest Image is Pulled
        run: |
          kubectl rollout restart deployment/catalog-${{ needs.determine-target.outputs.target_color }}
          kubectl rollout restart deployment/cart-${{ needs.determine-target.outputs.target_color }}
          kubectl rollout restart deployment/frontend-${{ needs.determine-target.outputs.target_color }}

  test-new:
    runs-on: ubuntu-latest
    needs: restart-pods
    steps:
      - name: Restore Kubernetes Context
        run: |
          echo "${{ needs.checkout-and-setup.outputs.kubeconfig }}" | base64 --decode > ~/.kube/config
          export KUBECONFIG=~/.kube/config

      - name: Get Blue and Green Pods
        id: get-pods
        run: |
          BLUE_POD=$(kubectl get pods -l app=catalog,version=blue -o jsonpath='{.items[0].metadata.name}')
          GREEN_POD=$(kubectl get pods -l app=catalog,version=green -o jsonpath='{.items[0].metadata.name}')
          echo "BLUE_POD=$BLUE_POD" >> $GITHUB_ENV
          echo "GREEN_POD=$GREEN_POD" >> $GITHUB_ENV

      - name: Run Health Check on New Deployment
        run: |
          if [ "${{ needs.determine-target.outputs.target_color }}" == "green" ]; then
            echo "Testing Green Deployment"
            kubectl exec $GREEN_POD -- curl -s http://localhost:8080/health || exit 1
          else
            echo "Testing Blue Deployment"
            kubectl exec $BLUE_POD -- curl -s http://localhost:8080/health || exit 1
          fi

  switch-traffic:
    runs-on: ubuntu-latest
    needs: test-new
    if: success()
    steps:
      - name: Restore Kubernetes Context
        run: |
          echo "${{ needs.checkout-and-setup.outputs.kubeconfig }}" | base64 --decode > ~/.kube/config
          export KUBECONFIG=~/.kube/config

      - name: Switch Traffic to New Deployment for all services
        run: |
          kubectl patch service catalog-service -p '{"spec":{"selector":{"version":"${{ needs.determine-target.outputs.target_color }}"}}}'
          kubectl patch service cart-service -p '{"spec":{"selector":{"version":"${{ needs.determine-target.outputs.target_color }}"}}}'
          kubectl patch service frontend-service -p '{"spec":{"selector":{"version":"${{ needs.determine-target.outputs.target_color }}"}}}'

  cleanup-old:
    runs-on: ubuntu-latest
    needs: switch-traffic
    steps:
      - name: Restore Kubernetes Context
        run: |
          echo "${{ needs.checkout-and-setup.outputs.kubeconfig }}" | base64 --decode > ~/.kube/config
          export KUBECONFIG=~/.kube/config

      - name: Scale Down Old Deployment Instead of Deleting (Free up resource but still idle for emergency)
        run: |
          kubectl scale deployment catalog-${{ needs.determine-target.outputs.idle_color }} --replicas=1
          kubectl scale deployment cart-${{ needs.determine-target.outputs.idle_color }} --replicas=1
          kubectl scale deployment frontend-${{ needs.determine-target.outputs.idle_color }} --replicas=1

  rollback:
    runs-on: ubuntu-latest
    needs: test-new
    if: failure()
    steps:
      - name: Restore Kubernetes Context
        run: |
          echo "${{ needs.checkout-and-setup.outputs.kubeconfig }}" | base64 --decode > ~/.kube/config
          export KUBECONFIG=~/.kube/config

      - name: Rollback to Previous Version
        run: |
          echo "Rolling back to previous version: ${{ needs.determine-target.outputs.idle_color }}"
          kubectl patch service catalog-service -p '{"spec":{"selector":{"version":"${{ needs.determine-target.outputs.idle_color }}"}}}'
          kubectl patch service cart-service -p '{"spec":{"selector":{"version":"${{ needs.determine-target.outputs.idle_color }}"}}}'
          kubectl patch service frontend-service -p '{"spec":{"selector":{"version":"${{ needs.determine-target.outputs.idle_color }}"}}}'
 
      - name: Notify Failure
        run: echo "Deployment failed. Rolled back to previous version."